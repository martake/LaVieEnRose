# 軌道微分＋随伴変数法によるパラメータ推定の比較実験

## 1. 目的

現在の `index.html` デモでは、世界の構造式 $A(\theta)$ の未知パラメータ $\theta = (\theta_r, \theta_s, \theta_d)$ を**有限差分法による数値勾配降下**で推定している。

本実験では、**軌道微分＋随伴変数法（adjoint method）** を導入し、同じ系に対するパラメータ推定の収束速度・精度を比較する。

### 動機

- 随伴変数法は「構造式の形は既知だが係数が未知」という状況に適した手法であり、本リポジトリの世界モデルがまさにこの構造を持つ
- 特に、複数ステップの軌道に沿った累積誤差から勾配を求める場合に、有限差分法に対して計算効率の優位性がある
- 手を動かして随伴変数法を実装・理解することも目的の一つ

## 2. 現在の実装（ベースライン）

### 世界モデル

潜在状態 $s_t \in \mathbb{R}^3$ が以下のダイナミクスに従う:

$$s_{t+1} = A(\theta) \cdot s_t + B \cdot a_t + \varepsilon_t$$

- $A(\theta)$: パラメータ $\theta$ で決まる 3×3 ダイナミクス行列
- $B$: 2D行動を3D潜在空間に持ち上げる 3×2 行列（既知・固定）
- $\varepsilon_t$: ガウスノイズ

観測は 2D 射影:

$$o_t = P \cdot s_t$$

- $P$: 固定の 2×3 射影行列（既知）

### パラメータ構造

$$A(\theta) = \begin{pmatrix} \theta_s \cos\theta_r & -\theta_s \sin\theta_r & 0 \\ \theta_s \sin\theta_r & \theta_s \cos\theta_r & 0 \\ 0 & 0 & 1 + 0.5\theta_d \end{pmatrix}$$

真値: $\theta_r = 0.15, \quad \theta_s = 0.98, \quad \theta_d = 0.12$

### 現在の推定手法（有限差分法）

各ステップで、各パラメータ $\theta_k$ について:

1. $\theta_k + \varepsilon$ と $\theta_k - \varepsilon$ でそれぞれ1ステップ先を予測
2. 観測誤差のノルムの差から勾配を近似: $\frac{\partial \|e\|}{\partial \theta_k} \approx \frac{\|e^+\| - \|e^-\|}{2\varepsilon}$
3. $\theta_k \leftarrow \theta_k - \eta \cdot \text{grad}$

1ステップあたり 6回の追加予測（3パラメータ × 2摂動）が必要。

## 3. 提案手法（随伴変数法）

### 基本的な考え方

有限差分で勾配を近似する代わりに、**軌道に沿った解析的な勾配**を計算する。

「構造式は分かっているが係数が分からない」場合、軌道（状態の時系列）のパラメータに対する感度を解析的に追跡できる。随伴変数法は、この感度計算を**軌道の終端から逆方向に伝搬する**ことで効率的に行う。

### 単一ステップの場合（直接感度法）

感度行列 $J_t^{(k)} = \frac{\partial s_t}{\partial \theta_k}$ を前方伝搬する:

$$J_{t+1}^{(k)} = \frac{\partial A}{\partial \theta_k} \cdot s_t + A(\theta) \cdot J_t^{(k)}$$

観測誤差 $e_{t+1} = o_{t+1} - \hat{o}_{t+1}$ に対する勾配:

$$\frac{\partial \|e\|^2}{\partial \theta_k} = -2 \, e_{t+1}^\top \cdot P \cdot J_{t+1}^{(k)}$$

$\frac{\partial A}{\partial \theta_k}$ は解析的に求まる:

$$\frac{\partial A}{\partial \theta_r} = \begin{pmatrix} -\theta_s \sin\theta_r & -\theta_s \cos\theta_r & 0 \\ \theta_s \cos\theta_r & -\theta_s \sin\theta_r & 0 \\ 0 & 0 & 0 \end{pmatrix}$$

$$\frac{\partial A}{\partial \theta_s} = \begin{pmatrix} \cos\theta_r & -\sin\theta_r & 0 \\ \sin\theta_r & \cos\theta_r & 0 \\ 0 & 0 & 0 \end{pmatrix}$$

$$\frac{\partial A}{\partial \theta_d} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0.5 \end{pmatrix}$$

### 複数ステップの場合（随伴変数法の本領）

過去 $W$ ステップの累積誤差をコスト関数とする:

$$L = \sum_{\tau=t-W+1}^{t} \|o_\tau - \hat{o}_\tau\|^2$$

**随伴変数** $\lambda_\tau$ を終端から逆方向に伝搬する:

$$\lambda_t = -2 \, P^\top (o_t - \hat{o}_t)$$

$$\lambda_{\tau-1} = A(\hat{\theta})^\top \cdot \lambda_\tau - 2 \, P^\top (o_{\tau-1} - \hat{o}_{\tau-1})$$

パラメータ勾配は随伴変数を用いて:

$$\frac{\partial L}{\partial \theta_k} = \sum_{\tau=t-W+1}^{t} \lambda_\tau^\top \cdot \frac{\partial A}{\partial \theta_k} \cdot \hat{s}_{\tau-1}$$

**計算量の比較:**

| 手法 | Wステップ・Nパラメータでの計算量 |
|------|------|
| 有限差分法 | $O(W \times 2N)$ 回の追加予測 |
| 直接感度法 | $O(W \times N)$ 回の行列演算 |
| 随伴変数法 | $O(W)$ の逆伝搬 + $O(N)$ の勾配計算 |

$N=3, W=10$ 程度ではどの手法も軽量だが、随伴変数法は **パラメータ数に依存しない** という構造的優位がある。

## 4. 実装計画

### 方針

- 既存の HTML デモ (`index.html`) はそのまま維持する（GitHub Pages 用）
- Python で同一の世界モデルを実装し、**1つの世界に2体のエージェントを同時配置**して比較する
- HTML版と同様に**探索経過がリアルタイムで見える UI** を用意する

### シミュレーション構成

```
┌─────────────────────────────────────────────┐
│              1つの世界 (World)               │
│         真のダイナミクス A(θ*), 報酬場       │
│                                             │
│   🔵 Agent A (有限差分法)                    │
│   🟠 Agent B (随伴変数法)                    │
│                                             │
│   - 同じ初期位置からスタート                 │
│   - 同じ報酬場を探索                         │
│   - 各自が独立にθを推定                     │
│   - 世界のノイズは共有（同一シード）          │
└─────────────────────────────────────────────┘
```

- 両エージェントは**同じ世界に存在するが互いに干渉しない**（各自の潜在状態は独立に遷移する）
- 同じ初期条件・同じノイズ系列を使うことで、学習手法の違いのみが比較対象になる

### UI 構成（matplotlib アニメーション）

HTML デモと対応する形で、以下の要素をリアルタイムに表示する:

```
┌──────────────────────────┬─────────────────────────┐
│                          │  θ推定バー (Agent A/B)  │
│     観測平面 (2D射影)     │  ───────────────────── │
│                          │  推定誤差の推移グラフ    │
│  🔵 Agent A の軌跡       │  ───────────────────── │
│  🟠 Agent B の軌跡       │  累積報酬の推移グラフ    │
│  背景 = 真の報酬場       │  ───────────────────── │
│                          │  ステップログ            │
├──────────────────────────┴─────────────────────────┤
│  [▶ 再生] [⏸ 一時停止] [1ステップ] [リセット]      │
│  速度: ■■■■□□  ウィンドウ幅W: ■■■□□□              │
└────────────────────────────────────────────────────┘
```

- **観測平面**: 2体のエージェントが同じ報酬場の上を移動する様子。色分けで区別
- **θ推定バー**: HTML版と同様、真値と推定値を並べて表示。2体分を上下に並べる
- **推定誤差グラフ**: 2本の線（Agent A / Agent B）を重ねて描画。差が一目で見える
- **累積報酬グラフ**: 同上
- **操作パネル**: 再生・停止・ステップ実行・リセット、速度調整、随伴法のウィンドウ幅W調整

### ファイル構成

```
python/
  world.py              — 世界モデル（A(θ), 射影P, 報酬関数、ノイズ生成）
  agent_base.py         — エージェント基底クラス（共通インターフェース）
  agent_finite_diff.py  — 有限差分法エージェント
  agent_adjoint.py      — 随伴変数法エージェント
  simulation.py         — 1つの世界 + 2体のエージェントを同時に進行させるループ
  ui.py                 — matplotlib アニメーション UI
  main.py               — エントリーポイント（実行用）
```

### 比較項目

1. **θ推定の収束速度**: 各ステップでの $\|\hat{\theta} - \theta^*\|$ の推移（2体を重ねて表示）
2. **観測予測精度**: 各ステップでの予測誤差 $\|e_t\|$ の推移
3. **累積報酬**: 構造の理解が進むと報酬が高い領域に向かえるか
4. **軌跡の違い**: 同じ報酬場での探索パターンの差異
5. **ウィンドウ幅 W の影響**: 随伴変数法において W を変えたときの収束への影響

### 実験条件

- 1つの世界に2体のエージェントを同時配置
- 同一の乱数シードで両エージェントのノイズを生成
- 初期条件: $s_0 = (1.0, 0.5, 0.0)$、$\hat{\theta}_0 = (0.0, 1.0, 0.0)$（両者共通）
- 学習率は各手法で個別に調整可能とする
- ステップ数: 200〜500ステップ程度

### 実装ステップ

1. `world.py` に世界モデルを移植（`index.html` の JS 実装と同等のロジック）
2. `agent_base.py` にエージェントの共通インターフェースを定義
3. `agent_finite_diff.py` に現行の有限差分法を移植
4. `agent_adjoint.py` に随伴変数法を実装
   - まず直接感度法（前方伝搬）で動作確認
   - 次にウィンドウ付き随伴変数法（逆伝搬）を実装
5. `simulation.py` で1つの世界 + 2体のエージェント同時進行ループを実装
6. `ui.py` で matplotlib アニメーション UI を実装
7. `main.py` で起動・パラメータ設定

## 5. 成功基準

- 随伴変数法が有限差分法より速く $\hat{\theta} \to \theta^*$ に収束することを確認する
  - もし収束速度に有意差がなければ、その理由を考察する（系が小さすぎる、ノイズの影響、等）
- 同じ報酬場の上で2体のエージェントの挙動の違いを観察し、随伴変数法の特性を直感的に理解する

## 6. 今後の予定

- 結果が良好であれば、HTML デモへの随伴変数法の組み込みを検討する（現在は対応不要）
